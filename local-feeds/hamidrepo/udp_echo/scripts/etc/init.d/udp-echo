#!/bin/sh /etc/rc.common
# procd-managed init script for udp_echo
# Lines beginning with comments explain what each part does.

USE_PROCD=1        # Tell rc.common to use procd service management
START=99           # Start order (higher starts later; after networking)

PROG=/usr/bin/udp_echo  # Path to the compiled binary installed by the package

# Optional: called by UCI parser to track the section name (here: "main")
config_cb() {
    # $1 = section type, $2 = section name; we only care when type is "service"
    [ "$1" = "service" ] && section="$2"
}

start_service() {
    # Load /etc/config/udp_echo into UCI runtime
    config_load udp_echo

    # Read values from the "service" section (set defaults where appropriate)
    local enabled addr port bufsize timestamp
    config_get_bool enabled  "$section" enabled     1
    [ "$enabled" -eq 1 ] || return 0  # If disabled, exit silently

    config_get      addr     "$section" listen_addr "0.0.0.0"
    config_get      port     "$section" port        "9000"
    config_get      bufsize  "$section" bufsize     "2048"
    config_get_bool timestamp "$section" timestamp  0

    # Open a procd instance named after the binary (implicit)
    procd_open_instance

    # Command line: run in foreground (-f) and pass addr/port/bufsize
    procd_set_param command "$PROG" -f -a "$addr" -p "$port" -b "$bufsize"

    # If UCI wants timestamps and the binary supports -t (help includes "-t"), append it.
    if [ "$timestamp" -eq 1 ] && "$PROG" -h 2>&1 | grep -q ' -t'; then
        procd_append_param command -t
    fi

    # Auto-restart: respawn (threshold 5s, timeout 10s, retries 5)
    procd_set_param respawn 5 10 5

    # Close and start the instance
    procd_close_instance
}

stop_service() {
    # procd stops processes automatically; no custom cleanup needed
    :
}
